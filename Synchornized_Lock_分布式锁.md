Lock：大量同步

Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）
在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；
ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。

Synchronaized：少量同步

![动图封面](https://pic2.zhimg.com/v2-33895a2c347d219976ad80ba53395925_b.jpg)

count++ 程序代码是一行，但是翻译成 CPU 指令确是三行（获取，计算，写入）( 不信你用 `javap -c` 命令试试)

synchronized 是独占锁/**排他锁**（就是有你没我的意思），同时只能有一个线程调用 `add10KCount` 方法，其他调用线程会被阻塞。所以三行 CPU 指令都是同一个线程执行完之后别的线程才能继续执行，这就是通常说说的 **原子性** （线程执行多条指令不被中断）

排他，线程排队就要有切换，切换需要保存上次的操作，带来很大的开销

但 **volatile 是非阻塞算法**（也就是不排他），当遇到三行 CPU 指令自然就不能保证别的线

因此，volatile 是 Synchronized 的弱同步体现

什么时候用volatile关键字：

如果写入变量不依赖于变量当前的值，就是用volatileita

volatile可以解决**可见性问题**，还能解决编译**优化重排序问题**



分布式锁和JVM锁（Synchronized，Lock）

JVM 锁只能作用于单个 JVM，可以简单理解为就是单台服务器（容器），而对于多台服务器之间，JVM 锁则没法解决，这时候就需要引入分布式锁。

常见实现分布式锁的方式有：数据库、Redis、Zookeeper。

Redis 实现分布式锁

1.加锁

set key value PX milliseconds NX

PX：设置键的过期时间

NX：用于保证在多个线程并发 set 下，只会有1个线程成功，起到了锁的“唯一”性。

2.解锁

1）查询当前“锁”是否还是我们持有，因为存在过期时间，所以可能等你想解锁的时候，“锁”已经到期，然后被其他线程获取了，所以我们在解锁前需要先判断自己是否还持有“锁”

2）如果“锁”还是我们持有，则执行解锁操作，也就是删除该键值对，并返回成功；否则，直接返回失败。

由于当前 Redis 还没有原子命令直接支持这两步操作，所以当前通常是使用 Lua 脚本来执行解锁操作，Redis 会保证脚本里的内容执行是一个原子操作。

![image-20230416115932960](C:\Users\18479\AppData\Roaming\Typora\typora-user-images\image-20230416115932960.png)

### Redis 分布式锁过期了，还没处理完怎么办

1、守护线程“续命”：额外起一个线程，定期检查线程是否还持有锁，如果有则延长过期时间。Redisson 里面就实现了这个方案，使用“看门狗”定期检查（每1/3的锁时间检查1次），如果线程还持有锁，则刷新过期时间。

 

2、超时回滚：当我们解锁时发现锁已经被其他线程获取了，说明此时我们执行的操作已经是“不安全”的了，此时需要进行回滚，并返回失败。